<?php
// $Id$

/**
 * @file
 * The Hacked! module, shows which project have been changed since download.
 *
 * We download the original project file, and hash all the files contained
 * within, then we hash our local copies and compare.
 * This module should never be used on a production server.
 */

define('HACKED_CACHE_TABLE', 'cache_hacked');

define('HACKED_STATUS_UNCHECKED', 1);
define('HACKED_STATUS_UNHACKED', 2);
define('HACKED_STATUS_HACKED', 3);
define('HACKED_STATUS_DELETED', 4);

/**
 * Implementation of hook_menu().
 */
function hacked_menu() {
  $items = array();

  $items['admin/reports/hacked'] = array(
    'title' => 'Hacked',
    'description' => 'Get a code hacking report about your installed modules and themes.',
    'page callback' => 'hacked_reports_hacked',
    'access arguments' => array('administer site configuration'),
    'weight' => 10,
  );

  $items['admin/reports/hacked/%hacked_project'] = array(
    'title callback' => 'hacked_reports_hacked_details_title',
    'title arguments' => array(3),
    'page callback' => 'hacked_reports_hacked_details',
    'page arguments' => array(3),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
    'file' => 'hacked.details.inc',
  );

  $items['admin/reports/hacked/%hacked_project/diff/%hacked_tail'] = array(
    'title callback' => 'hacked_reports_hacked_diff_title',
    'title arguments' => array(3, 5),
    'load arguments'   => array('%map', '%index'),
    'page callback' => 'hacked_reports_hacked_diff',
    'page arguments' => array(3, 5),
    'access arguments' => array('view diffs of changed files'),
    'type' => MENU_CALLBACK,
    'file' => 'hacked.diff.inc',
  );

  return $items;
}

/**
 * Helper to load the menu tail properly.
 *
 * Specifed as %hacked_tail in a menu path, this will return the entirety
 * of the the rest of the menu path.
 */
function hacked_tail_load($arg, $map, $index) {
  return implode('/', array_slice($map, $index));
}

/**
 * Menu loader for loading a project from its short name.
 *
 * In this function we call the calculate function both the update module and
 * our hacked module. This may mean we return FALSE when there is no internet
 * connection.
 *
 * @param $short_name The short name of the project to load.
 */
function hacked_project_load($short_name) {
  $available = update_get_available();
  $data = update_calculate_project_data($available);
  foreach ($data as $key => $project) {
    if ($project['short_name'] == $short_name) {
      $data_truncated = array($key => $project);
      $data_truncated = hacked_calculate_project_data($data_truncated);
      return $data_truncated[$key];
    }
  }
  return FALSE;
}

/**
 * Menu title callback for the hacked details page.
 */
function hacked_reports_hacked_details_title($project) {
  return t('Hacked status for @project', array('@project' => $project['title']));
}

/**
 * Menu title callback for the hacked site report page.
 */
function hacked_reports_hacked_diff_title($project, $file) {
  return t('Hacked status for file @file in project @project', array('@project' => $project['title'], '@file' => $file));
}

/**
 * Implementation of the hook_theme() registry.
 */
function hacked_theme() {
  return array(
    'hacked_report' => array(
      'arguments' => array('data' => NULL),
      'file' => 'hacked.theme.inc',
    ),
    'hacked_detailed_report' => array(
      'arguments' => array('data' => NULL),
      'file' => 'hacked.details.inc',
    ),
  );
}

/**
 * Implementation of hook_perm().
 */
function hacked_perm() {
  return array(
    'view diffs of changed files',
  );
}

function hacked_reports_hacked() {
  // We're going to be borrowing heavily from the update module
  module_load_include('inc', 'update', 'update.report');
  if ($available = update_get_available(TRUE)) {
    module_load_include('inc', 'update', 'update.compare');
    $data = update_calculate_project_data($available);
    $data = hacked_calculate_project_data($data);
    return theme('hacked_report', $data);
  }
  else {
    return theme('update_report', _update_no_data());
  }

}

function hacked_process_module($project) {
  hacked_hash_project($project);
}

function hacked_calculate_project_data($projects) {
  foreach ($projects as $project_key => $project) {
    if ($project['install_type'] == 'official') {
      $projects[$project_key]['hacked_status'] = HACKED_STATUS_UNCHECKED;
      // Go get the hashes of the clean copy of the installed version:
      $projects[$project_key]['clean_hashes'] = hacked_hash_project($project);
      // If we got some hashes, let's compare it with the local copy:
      if ($projects[$project_key]['clean_hashes']) {
        hacked_hash_local($projects[$project_key]);
        $hacked_count = 0;
        $deleted_count = 0;

        // Now do the comparison:
        foreach ($projects[$project_key]['clean_hashes'] as $file => $hash) {
          // Has the file been deleted:
          if (!isset($projects[$project_key]['local_hashes'][$file])) {
            $deleted_count++;
            $projects[$project_key]['hacked_results'][$file] = HACKED_STATUS_DELETED;
          }
          else {
            // We have the file, so has it been changed:
            if ($projects[$project_key]['local_hashes'][$file] != $hash) {
              $hacked_count++;
              $projects[$project_key]['hacked_results'][$file] = HACKED_STATUS_HACKED;
            }
            else {
              $projects[$project_key]['hacked_results'][$file] = HACKED_STATUS_UNHACKED;
            }
          }
        }

        // Record aggregate stats
        $projects[$project_key]['changed_count'] = $hacked_count;
        $projects[$project_key]['deleted_count'] = $deleted_count;
        if ($hacked_count) {
          $projects[$project_key]['hacked_status'] = HACKED_STATUS_HACKED;
        }
        else {
          $projects[$project_key]['hacked_status'] = HACKED_STATUS_UNHACKED;
        }
      }



    }
  }


  return $projects;
}

function hacked_hash_project($project) {
  if (($project['project_type'] == 'module') || ($project['project_type'] == 'theme') || ($project['project_type'] == 'core')) {
    if (isset($project['existing_version']) && isset($project['releases'][$project['existing_version']])) {
      $this_release = $project['releases'][$project['existing_version']];

      // Let's see if there's a download link:
      $dir = hacked_download_release($this_release['download_link'], $project['project_type'], $project['short_name'], $project['existing_version']);
      // Now hash that dir:
      $hashed = hacked_release_generate_hashes_cached($project['project_type'], $project['short_name'], $project['existing_version']);
      return $hashed;


    }
  }
}

function hacked_hash_local(&$project) {
  // Are there other types of project we should handle?
  if (($project['project_type'] == 'module')  || ($project['project_type'] == 'theme')|| ($project['project_type'] == 'core')) {
    if ($dir = hacked_find_local_project_directory($project)) {
      $project['local_hashes'] = hacked_scan_directory_generate_hashes($dir, TRUE);
    }
    else {
      $project['local_hashes'] = array();
    }
  }
}

/**
 * Return the location of the installed project.
 *
 * As drupal modules do not need to be named the same as the projects they are
 * part of we need to be a little smarter about how we find the project
 * directory to start hashing in.
 */
function hacked_find_local_project_directory($project) {
  // Do we have at least some modules to check for:
  if (!is_array($project['includes']) || !count($project['includes'])) {
    return FALSE;
  }

  // If this project is drupal it, we need to handle it specially
  if ($project['project_type'] != 'core') {
    $include = array_shift(array_keys($project['includes']));
    $include_type = $project['project_type'];
  }
  else {
    // Just use the system module to find where we've installed drupal
    $include = 'system';
    $include_type = 'module';
  }

  $path = drupal_get_path($include_type, $include);

  // Now we need to find the path of the info file in the downloaded package:
  $temp = '';
  foreach ($project['clean_hashes'] as $file => $hash) {
    if (strpos($file, "$include.info") !== FALSE) {
      // TODO: Replace this with a regular expression
      $temp = str_replace("$include.info", '', $file);
      break;
    }
  }

  // How many '/' were in that path:
  $slash_count = substr_count($temp, '/');
  $back_track = str_repeat('/..', $slash_count);
  return realpath($path . $back_track);

}

/**
 * A standard method of forming the path name of the local copy of a project
 */
function hacked_release_form_path_name($type, $name, $version) {
  $dir = file_directory_temp() . "/hacked-cache/$type/$name";
  // Build the destination folder tree if it doesn't already exists.
  if (!file_check_directory($dir, FILE_CREATE_DIRECTORY) && !mkdir($dir, 0775, TRUE)) {
    watchdog('hacked', 'Failed to create temp directory: %dir', array('%dir' => $dir), WATCHDOG_ERROR);
    return FALSE;
  }
  return file_create_path(file_directory_temp() . "/hacked-cache/$type/$name/$version");
}

function hacked_download_release($release_url, $type, $short_name, $version) {

  // Compute the path where we'll store this release:
  $dir = hacked_release_form_path_name($type, $short_name, $version);


  // If our directory already exists, we can just return the path to this cached version
  if (file_exists($dir)) {
    return $dir;
  }

  // We've not downloaded this release before:
  // Let's try to download it:
  $request = drupal_http_request($release_url);

  // If we downloaded it, try to unpack it:
  if ($request->code == 200) {

    // Build the destination folder tree if it doesn't already exists.
    if (!file_check_directory($dir, FILE_CREATE_DIRECTORY) && !mkdir($dir, 0775, TRUE)) {
      watchdog('hacked', 'Failed to create temp directory: %dir', array('%dir' => $dir), WATCHDOG_ERROR);
      return FALSE;
    }

    // Save the tarball someplace:
    $project_path = file_create_path($dir . '/' . basename($release_url));
    file_save_data($request->data, $project_path);
    shell_exec("cd $dir; tar -zxf ". basename($project_path));
    file_delete($project_path);
    // If we unpacked it, return the path:

    return $dir;

  }

  // Something went wrong:
  return FALSE;
}

function hacked_release_generate_hashes($type, $short_name, $version) {
  $dir = hacked_release_form_path_name($type, $short_name, $version);


  // More special handling for core:
  if ($type != 'core') {
    $module_dir = $dir . "/$short_name";
  }
  else {
    $module_dir = $dir . "/$short_name-$version";
  }

  // Scan the directory for files:
  $hashes = hacked_scan_directory_generate_hashes($module_dir);
  return $hashes;
}

function hacked_release_generate_hashes_cached($type, $short_name, $version) {
  static $cached;
  if (is_null($cached)) {
    $cached = array();
  }

  // Return from the static cache if we can:
  if (isset($cached[$type][$short_name][$version])) {
    return $cached[$type][$short_name][$version];
  }

  // Return form the cache system if we can:
  $key = "hacked:clean:hashes:$type:$short_name:$version";
  $cache = cache_get($key, HACKED_CACHE_TABLE);
  if ($cache && isset($cache->data)) {
    return $cache->data;
  }

  // Otherwise pass through to the actual function:
  $cached[$type][$short_name][$version] = hacked_release_generate_hashes($type, $short_name, $version);

  // Save into the cache table:
  cache_set($key, $cached[$type][$short_name][$version], HACKED_CACHE_TABLE);

  // Return the hashes:
  return $cached[$type][$short_name][$version];
}

/**
 * Hash the contents of a directory, optionally retrieving from cache.
 *
 * @param $directory The directory to hash.
 * @param $cache Can I use a cache for the files in this directory?
 */
function hacked_scan_directory_generate_hashes($directory, $cache = FALSE) {

  $timestamps = array();
  // Try to load some details from the cache:
  if ($cache) {
    $key = "hacked:directory:timestamps:$directory";
    // The key could get really long, guard against that:
    if (strlen($key) > 255) {
      $key = "hacked:directory:timestamps:" . sha1($directory);
    }
    $cache_ob = cache_get($key, HACKED_CACHE_TABLE);
    if ($cache_ob && isset($cache_ob->data)) {
      $timestamps = $cache_ob->data;
    }
  }

  $hashes = array();
  $files = file_scan_directory($directory, '.*');
  foreach ($files as $file) {
    $filename = str_replace($directory . '/', '', $file->filename);
    // Check the timestamp if available:
    if ((isset($timestamps[$file->filename])) && (filemtime($file->filename) == $timestamps[$file->filename]['timestamp'])) {
      $hashes[$filename] = $timestamps[$file->filename]['hash'];
    }
    else {
      $timestamps[$file->filename]['hash'] = $hashes[$filename] = sha1_file($file->filename);
      $timestamps[$file->filename]['timestamp'] = filemtime($file->filename);
    }
  }

  if ($cache) {
    cache_set($key, $timestamps, HACKED_CACHE_TABLE);
  }

  return $hashes;
}

function hacked_file_is_binary($file) {
  if (file_exists($file)) {
    if (!is_file($file)) return 0;

    $fh  = fopen($file, "r");
    $blk = fread($fh, 512);
    fclose($fh);
    clearstatcache();

    return (
      0 or substr_count($blk, "^ -~", "^\r\n")/512 > 0.3
        or substr_count($blk, "\x00") > 0
    );
  }
  return 0;
}
